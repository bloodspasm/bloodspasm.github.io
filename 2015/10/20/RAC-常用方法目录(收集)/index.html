<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>RAC | 此去经年</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="如今的我，谈不上幸福，也谈不上不幸。一切都会过去的。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="RAC | 此去经年">
    <meta name="twitter:description" content="如今的我，谈不上幸福，也谈不上不幸。一切都会过去的。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="RAC | 此去经年">
    <meta property="og:description" content="如今的我，谈不上幸福，也谈不上不幸。一切都会过去的。">

    
    <meta name="author" content="bloodspasm">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://yoursite.com/2015/10/20/RAC-常用方法目录(收集)/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 此去经年 的主页"><img src="/images/default_avatar.png" width="80" alt="此去经年 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 此去经年">此去经年</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">小布先生的Blog</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">如今的我，谈不上幸福，也谈不上不幸。一切都会过去的。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文字阁</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/p/1005051692500745" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/bloodspasm" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/bloodspasm" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-10-19T22:49:50.000Z" class="post-list__meta--date date">2015-10-20</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/RAC/">RAC</a>, <a class="tag-link" href="/tags/code/">code</a>, <a class="tag-link" href="/tags/iOS/">iOS</a>
 </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">RAC</h1>
  </header>

  <section class="post">
    <pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    /*******************************第一部分----简单使用*******************************/
    //文本框事件：
    [self textFiledTest];
    //手势
    [self gestureTest];
    //通知
    [self notificationTest];
    //定时器NSTime
    [self timeTest];
    //代理 (有局限，只能取代没有返回值的代理方法)
    [self delegateTest];
    //KVO
    [self kvoTest];
    /*******************************第二部分----进阶*******************************/
    //双向绑定
    [self banding];
    //信号 （创建信号 &amp; 激活信号 &amp; 废弃信号）
    [self createSignal];
    //信号的处理
    //map (映射)和filter
    [self mapAndFilter];
    //delay延迟
    [self delay];
    //最先开始的时候
    [self startWith];
    //超时
    [self timeOut];
    //take skip
    [self takeOrSkip];
    //throttle(截流)  结合即时搜索优化来讲
    [self throttle];
    //repeat 重复
    [self repeatTest];
    //merge 合并信号
    [self mergeTest];
    //RAC(TARGET, ...) 宏
    [self RAC];
    //rac做一个秒表
    [self stopwatch]; 
    //压缩同合并     ab: ab=&gt;
    [self zipWith];
    //活合并       ab: a=&gt; b=&gt;
    [self merge];
    //过滤合并      ab: b=&gt;
    [self then];
    //顺序合并      ab: a-&gt;b=&gt;
    [self concat];
}
 #pragma mark 0.双向绑定
- (void)banding{
    RACChannelTerminal *channelA = RACChannelTo(self, valueA);
    RACChannelTerminal *channelB = RACChannelTo(self, valueB);
    [[channelA map:^id(NSString *value) {
        if ([value isEqualToString:@&quot;西&quot;]) {
                return @&quot;东&quot;;
            }
        return value;
    }] subscribe:channelB];
    [[channelB map:^id(NSString *value) {
        if ([value isEqualToString:@&quot;左&quot;]) {
                return @&quot;右&quot;;
            }
        return value;
    }] subscribe:channelA];

    [RACObserve(self, valueA) subscribeNext:^(NSString* x) {
        NSLog(@&quot;你向%@&quot;, x);
    }];
    [RACObserve(self, valueB) subscribeNext:^(NSString* x) {
        NSLog(@&quot;他向%@&quot;, x);
    }];
    self.valueA = @&quot;西&quot;;
    self.valueB = @&quot;左&quot;;
}

 #pragma mark 1.文本框事件
- (void)textFiledTest{

    UITextField * textField = ({
        UITextField * textField = [[UITextField alloc]init];
        textField.backgroundColor = [UIColor cyanColor];

        textField;
    });
   [self.view addSubview:textField];

    @weakify(self); //  __weak __typeof__(self) self_weak_ = self;

    [textField mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);    // __strong __typeof__(self) self = self_weak_;
        make.size.mas_equalTo(CGSizeMake(180, 40));
        make.center.equalTo(self.view);
    }];

    [[textField rac_signalForControlEvents:UIControlEventEditingChanged]
     subscribeNext:^(id x) {

         LxDBAnyVar(x);
     }];
    //更简单的方式
    [textField.rac_textSignal subscribeNext:^(NSString *x) {

        LxDBAnyVar(x);
    }];
}

#pragma mark 2.手势
- (void)gestureTest
{
    self.view.userInteractionEnabled = YES;
    UITapGestureRecognizer * tap = [[UITapGestureRecognizer alloc]init];
    [[tap rac_gestureSignal] subscribeNext:^(UITapGestureRecognizer * tap) {

        LxDBAnyVar(tap);
    }];
    [self.view addGestureRecognizer:tap];
}

 #pragma mark 3.通知
- (void)notificationTest
{
    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(NSNotification * notification) {

        LxDBAnyVar(notification);
    }];
    //不需要removeObserver
}

#pragma mark 4.定时器
- (void)timeTest
{
    //1. 延迟某个时间后再做某件事
    [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{

        LxPrintAnything(rac);
    }];

    //2. 每间隔多长时间做一件事
    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]subscribeNext:^(NSDate * date) {

        LxDBAnyVar(date);
    }];

}

#pragma mark 5.代理
- (void)delegateTest
{
    UIAlertView * alertView = [[UIAlertView alloc]initWithTitle:@&quot;RAC&quot; message:@&quot;ReactiveCocoa&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Ensure&quot;, nil];

    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple * tuple) {

        LxDBAnyVar(tuple);

        LxDBAnyVar(tuple.first);
        LxDBAnyVar(tuple.second);
        LxDBAnyVar(tuple.third);
    }];
    [alertView show];


    //    更简单的方式：
    [[alertView rac_buttonClickedSignal]subscribeNext:^(id x) {

        LxDBAnyVar(x);
    }];

}

#pragma mark 6.KVO
/**    
 *  KVO
 *  RACObserveL:快速的监听某个对象的某个属性改变
 *  返回的是一个信号,对象的某个属性改变的信号

- (void)test2 {
    [RACObserve(self.view, center) subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;, x);
    }];
}
- (void)testAndtest2 // textField输入的值赋值给label，监听label文字改变,
    {

        RAC(self.label, text) = self.textField.rac_textSignal;
        [RACObserve(self.label, text) subscribeNext:^(id x) {
            NSLog(@&quot;====label的文字变了&quot;);
        }];  
}      
     */
- (void)kvoTest
{
    UIScrollView * scrollView = [[UIScrollView alloc]init];
    scrollView.delegate = (id&lt;UIScrollViewDelegate&gt;)self;
    [self.view addSubview:scrollView];

    UIView * scrollViewContentView = [[UIView alloc]init];
    scrollViewContentView.backgroundColor = [UIColor yellowColor];
    [scrollView addSubview:scrollViewContentView];

    @weakify(self);

    [scrollView mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);
        make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(80, 80, 80, 80));
    }];

    [scrollViewContentView mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);
        make.edges.equalTo(scrollView);
        make.size.mas_equalTo(CGSizeMake(CGRectGetWidth(self.view.frame), CGRectGetHeight(self.view.frame)));
    }];

    [RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {

        LxDBAnyVar(x);
    }];

//  （好处：写法简单，keypath有代码提示）
}

#pragma mark - concat 顺序合并
// concat----- 使用需求：有两部分数据：想让上部分先执行，完了之后再让下部分执行（都可获取值）
- (void)concat {
    // 组合

    // 创建信号A
    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        // 发送请求
                NSLog(@&quot;----发送上部分请求---afn&quot;);

        [subscriber sendNext:@&quot;上部分数据&quot;];
        [subscriber sendCompleted]; // 必须要调用sendCompleted方法！
        return nil;
    }];

    // 创建信号B，
    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        // 发送请求
                NSLog(@&quot;--发送下部分请求--afn&quot;);
        [subscriber sendNext:@&quot;下部分数据&quot;];
        return nil;
    }];


    // concat:按顺序去链接
    //**-注意-**：concat，第一个信号必须要调用sendCompleted
    // 创建组合信号
    RACSignal *concatSignal = [signalA concat:signalsB];
    // 订阅组合信号
    [concatSignal subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;,x);
    }];

}

#pragma mark - zipWith 只有当两个信号同时发出信号内容时
- (void)zipWith {
    //zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元祖，才会触发压缩流的next事件。
    // 创建信号A
    RACSubject *signalA = [RACSubject subject];
    // 创建信号B
    RACSubject *signalB = [RACSubject subject];
    // 压缩成一个信号
    // **-zipWith-**: 当一个界面多个请求的时候，要等所有请求完成才更新UI
    // 等所有信号都发送内容的时候才会调用
    RACSignal *zipSignal = [signalA zipWith:signalB];
    [zipSignal subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;, x); //所有的值都被包装成了元组
    }];

    // 发送信号 交互顺序，元组内元素的顺序不会变，跟发送的顺序无关，而是跟压缩的顺序有关[signalA zipWith:signalB]---先是A后是B
    [signalA sendNext:@1];
    [signalB sendNext:@2];

}

#pragma mark - merge 多个信号合并成一个信号，任何一个信号有新值就会调用
// 任何一个信号请求完成都会被订阅到
// merge:多个信号合并成一个信号，任何一个信号有新值就会调用
- (void)merge {
    // 创建信号A
    RACSubject *signalA = [RACSubject subject];
    // 创建信号B
    RACSubject *signalB = [RACSubject subject];
    //组合信号
    RACSignal *mergeSignal = [signalA merge:signalB];
    // 订阅信号
    [mergeSignal subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;, x);
    }];
    // 发送信号---交换位置则数据结果顺序也会交换
    [signalB sendNext:@&quot;下部分&quot;];
    [signalA sendNext:@&quot;上部分&quot;];
}

#pragma mark - then
// then --- 使用需求：有两部分数据：想让上部分先进行网络请求但是过滤掉数据，然后进行下部分的，拿到下部分数据
- (void)then {
    // 创建信号A
    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        // 发送请求
        NSLog(@&quot;----发送上部分请求---afn&quot;);

        [subscriber sendNext:@&quot;上部分数据&quot;];
        [subscriber sendCompleted]; // 必须要调用sendCompleted方法！
        return nil;
    }];

    // 创建信号B，
    RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        // 发送请求
        NSLog(@&quot;--发送下部分请求--afn&quot;);
        [subscriber sendNext:@&quot;下部分数据&quot;];
        [subscriber sendCompleted];
        return nil;
    }];
    // 创建组合信号
    // then;忽略掉第一个信号的所有值
    RACSignal *thenSignal = [signalA then:^RACSignal *{
        // 返回的信号就是要组合的信号
        return signalsB;
    }];

    // 订阅信号
    [thenSignal subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;, x);
    }];

}

#pragma mark stopwatch
- (void)stopwatch
{
    UILabel * label = ({

        UILabel * label = [[UILabel alloc]init];
        label.backgroundColor = [UIColor cyanColor];
        label;
    });
    [self.view addSubview:label];

    @weakify(self);

    [label mas_makeConstraints:^(MASConstraintMaker *make) {
        @strongify(self);

        make.size.mas_equalTo(CGSizeMake(240, 40));
        make.center.equalTo(self.view);

    }];

    RAC(label, text) = [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] map:^NSString *(NSDate * date) {

        return date.description;
    }];
}
#pragma mark 8.RAC
- (void)RAC
{
    //button setBackgroundColor:forState:

    UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom];
    [self.view addSubview:button];

    @weakify(self);

    [button mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);
        make.size.mas_equalTo(CGSizeMake(180, 40));
        make.center.equalTo(self.view);
    }];

    /**
      RAC:把一个对象的某个属性绑定一个信号,只要发出信号,就会把信号的内容给对象的属性赋值
      给label的text属性绑定了文本框改变的信号
        RAC(self.label, text) = self.textField.rac_textSignal;
         [self.textField.rac_textSignal subscribeNext:^(id x) {
             self.label.text = x;
         }];
     */
    RAC(button, backgroundColor) = [RACObserve(button, selected) map:^UIColor *(NSNumber * selected) {
        return [selected boolValue] ? [UIColor redColor] : [UIColor greenColor];
    }];

    //rac_valuesForKeyPath:
    [[button rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(UIButton * btn) {  
        btn.selected = !btn.selected;
    }];

    //tableView Cell
    // [[[button rac_signalForControlEvents:UIControlEventTouchUpInside] takeUntil:self.rac_prepareForReuseSignal] subscribeNext:^(UIButton *x) {
    // do other things
   //  }];

}

#pragma mark - 9.RACSignal   
/**
 RACSignal使用步骤：
 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe
 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
 3.发送信号 - (void)sendNext:(id)value

 RACSignal底层实现：
 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。
 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock
 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。
 2.1 subscribeNext内部会调用siganl的didSubscribe
 3.siganl的didSubscribe中调用[subscriber sendNext:@1];
 3.1 sendNext底层其实就是执行subscriber的nextBlock

 *  总结：
 我们完全可以用RACSubject代替代理/通知，确实方便许多
 这里我们点击TwoViewController的pop的时候将字符串&quot;ws&quot;传给了ViewController的button的title。
 步骤：
 // 1.创建信号
 RACSubject *subject = [RACSubject subject];

 // 2.订阅信号
 [subject subscribeNext:^(id x) {
 // block:当有数据发出的时候就会调用
 // block:处理数据
 NSLog(@&quot;%@&quot;,x);
 }];

 // 3.发送信号
 [subject sendNext:value];
 **注意：~~**
 RACSubject和RACReplaySubject的区别
 RACSubject必须要先订阅信号之后才能发送信号，而RACReplaySubject可以先发送信号后订阅.
 RACSubject 代码中体现为：先走TwoViewController的sendNext，后走ViewController的subscribeNext订阅
 RACReplaySubject 代码中体现为：先走ViewController的subscribeNext订阅，后走TwoViewController的sendNext
 可按实际情况各取所需。

 */

#pragma  mark repeat
- (void)repeatTest
{
    //repeat:
    [[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [subscriber sendNext:@&quot;rac&quot;];
        [subscriber sendCompleted];

        return nil;
    }]delay:1]repeat]take:3] subscribeNext:^(id x) {

        LxDBAnyVar(x);
    } completed:^{

        LxPrintAnything(completed);
    }];

}
#pragma mark  throttle
- (void)throttle
{
    UITextField * textField = [[UITextField alloc]init];
    textField.backgroundColor = [UIColor cyanColor];
    [self.view addSubview:textField];

    @weakify(self);

    [textField mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);
        make.size.mas_equalTo(CGSizeMake(180, 40));
        make.center.equalTo(self.view);
    }];
    //throttle 后面是个时间 表示rac_textSignal发送消息，0.3秒内没有再次发送就会相应，若是0.3内又发送消息了，便会在新的信息处重新计时
    //distinctUntilChanged 表示两个消息相同的时候，只会发送一个请求
    //ignore 表示如果消息和ignore后面的消息相同，则会忽略掉这条消息，不让其发送

    [[[[[[textField.rac_textSignal throttle:0.3] distinctUntilChanged] ignore:@&quot;&quot;] map:^id(id value) {

        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

            //  network request
            [subscriber sendNext:value];
            [subscriber sendCompleted];

            return [RACDisposable disposableWithBlock:^{

                //  cancel request
            }];
        }];
    }]switchToLatest] subscribeNext:^(id x) {

        LxDBAnyVar(x);
    }];


}
#pragma mark takeOrSkip
- (void)takeOrSkip
{
    RACSignal * signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@&quot;rac1&quot;];
        [subscriber sendNext:@&quot;rac2&quot;];
        [subscriber sendNext:@&quot;rac3&quot;];
        [subscriber sendNext:@&quot;rac4&quot;];
        [subscriber sendCompleted];
        return nil;
    }]take:2];//Skip takeLast  takeUntil   takeWhileBlock:   skipWhileBlock:  skipUntilBlock:


    [signal subscribeNext:^(id x) {
        LxDBAnyVar(x);
    }];
}
#pragma mark timeOut
- (void)timeOut
{
    [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [[RACScheduler mainThreadScheduler]afterDelay:3 schedule:^{

            [subscriber sendNext:@&quot;rac&quot;];
            [subscriber sendCompleted];
        }];

        return nil;
    }] timeout:2 onScheduler:[RACScheduler mainThreadScheduler]]
     subscribeNext:^(id x) {

         LxDBAnyVar(x);
     } error:^(NSError *error) {

         LxDBAnyVar(error);
     } completed:^{

         LxPrintAnything(completed);
     }];

}
#pragma mark startWith
- (void)startWith
{
    RACSignal * signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [subscriber sendNext:@&quot;123&quot;];//startWith:@&quot;123&quot;等同于这句话 也就是第一个发送，主要是位置
        [subscriber sendNext:@&quot;rac&quot;];
        [subscriber sendCompleted];
        return nil;
    }]startWith:@&quot;123&quot;];
    LxPrintAnything(start);
    //创建订阅者
    [signal subscribeNext:^(id x) {
        LxDBAnyVar(x);
    }];

}
#pragma mark delay
- (void)delay
{
    //创建信号
    RACSignal * signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@&quot;rac&quot;];
        [subscriber sendCompleted];
        return nil;
    }]delay:2];
    LxPrintAnything(start);
    //创建订阅者
    [signal subscribeNext:^(id x) {
        LxDBAnyVar(x);
    }];

}
#pragma mark map (映射)和filter
- (void)mapAndFilter
{
    UITextField * textField = ({
        UITextField * textField = [[UITextField alloc]init];
        textField.backgroundColor = [UIColor cyanColor];

        textField;
    });
    [self.view addSubview:textField];

    @weakify(self); //  __weak __typeof__(self) self_weak_ = self;

    [textField mas_makeConstraints:^(MASConstraintMaker *make) {

        @strongify(self);    // __strong __typeof__(self) self = self_weak_;
        make.size.mas_equalTo(CGSizeMake(180, 40));
        make.center.equalTo(self.view);
    }];

    [[[textField.rac_textSignal map:^id(NSString *text) {

       LxDBAnyVar(text);

        return @(text.length);

    }]filter:^BOOL(NSNumber *value) {

        return value.integerValue &gt; 3;

    }] subscribeNext:^(id x) {
         LxDBAnyVar(x);
    }];

}
#pragma mark Signal
- (RACSignal *)createSignal
{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        RACDisposable * schedulerDisposable = [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{

            if (arc4random()%10 &gt; 1) {

                [subscriber sendNext:@&quot;Login response&quot;];
                [subscriber sendCompleted];
            }
            else {

                [subscriber sendError:[NSError errorWithDomain:@&quot;LOGIN_ERROR_DOMAIN&quot; code:444 userInfo:@{}]];
            }
        }];

        return [RACDisposable disposableWithBlock:^{

            [schedulerDisposable dispose];
        }];
    }];
}

#pragma mark 缩键盘
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [self.view endEditing:YES];
}
@end
</code></pre><blockquote>
<p>常见报错</p>
</blockquote>
<p>1.升级XCode7.3 后RAC报错“Cannot create __weak reference in file using manual reference counting”解决办法(<a href="http://blog.csdn.net/ouq68/article/details/51003876" target="_blank" rel="noopener">http://blog.csdn.net/ouq68/article/details/51003876</a>)</p>
<p>Please set ‘Weak References in Manual Retain Release:YES’. </p>
<p>2.[!] The <code>Paopao [Debug]</code> target overrides the <code>PODS_ROOT</code> build setting defined in `….</p>
<p>我想要使用 CocoaPods 中的设置，分别在我的项目中定义PODS_ROOT<br> 和 Other Linker Flags 的地方，把他们的值用$(inherited) 替换掉，进入终端，执行</p>
<p>Demo 地址:<strong><a href="https://github.com/bloodspasm/RACDemo-master" target="_blank" rel="noopener">RACDemo-master</a></strong></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/10/20/Markdown 语法和 MWeb 写作使用说明/" title="Markdown 语法和 MWeb 写作使用说明">Markdown 语法和 MWeb 写作使用说明</a></h2>
                <p class="excerpt">
                
                Markdown 的设计哲学
Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。

                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-10-19T22:49:50.000Z" class="post-list__meta--date date">2015-10-20</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/Markdown/">Markdown</a>, <a class="tag-link" href="/tags/code/">code</a>
</span><a class="btn-border-small" href="/2015/10/20/Markdown 语法和 MWeb 写作使用说明/">继续阅读</a></div>
                           
            </div>
        
        
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 bloodspasm - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?41918936ba907ae92396430db2ac1aa1";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
